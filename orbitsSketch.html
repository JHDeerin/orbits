<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Orbits</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#282c34',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: true
            }
        },
        scene: {
            create: create,
            update: update
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
    }

    let planets;
    let gravityObjects = [];
    let playerPlanet;

    let graphics;

    class Planet extends Phaser.GameObjects.Image {
        constructor(scene, distance, color, radius) {
            // Create planet "image" from graphics
            graphics.clear();
            graphics.fillStyle(color, 1);
            // TODO: Why does shifting this position affect the image??? Generate image from (0,0), maybe?
            graphics.fillCircle(radius, radius, radius);

            const spriteKey = `planet${planets.getLength()}`;
            graphics.generateTexture(spriteKey, 2*radius, 2*radius);

            let initialPosition = new Phaser.Math.Vector2();
            super(scene, initialPosition.x, initialPosition.y, spriteKey);
            scene.add.existing(this);

            this.t = 0;
            this.radius = radius;

            this.orbitDistance = distance;
            this.mass = radius**2;

            this.orbitPath = new Phaser.Curves.Path();
            this.orbitPath.add(new Phaser.Curves.Ellipse(
                scene.cameras.main.centerX,
                scene.cameras.main.centerY,
                distance
            ));

            scene.tweens.add({
                targets: this,
                t: 1,   // Increase until t hits 1, then loop
                duration: Math.ceil(this.calcOrbitDuration(distance)),
                repeat: -1
            });

            scene.physics.add.existing(this);
            this.body.setCircle(radius);
        }

        calcOrbitDuration(distance) {
            // Assume 400 units away = 300s orbit
            //  Use Kepler's 3rd law to calculate expected duration
            const baseCircleArea = Math.PI * 400.0**2;
            const baseCircleTime = 300000;   // 300000ms, or 300s
            const currentOrbitArea = Math.PI * distance**2;

            return baseCircleTime * currentOrbitArea / baseCircleArea;
        }

        updatePosition() {
            let newPosition = new Phaser.Math.Vector2();
            this.orbitPath.getPoint(this.t, newPosition);
            this.setPosition(newPosition.x, newPosition.y);
        }

        drawObject() {}

        destroy() {
            this.physicsSprite.destroy();
        }
    }

    // NOTE: Gravity objects are affected by gravity, but do NOT affect one another
    class GravityObject {
        constructor(scene, position, velocity, color) {
            this.position = position;
            this.velocity = velocity;
            this.accel = new Phaser.Math.Vector2();

            graphics.clear();
            graphics.fillStyle(color, 1);
            // TODO: Why does shifting this position affect the image??? Generate image from (0,0), maybe?
            graphics.fillCircle(1, 1, 1);

            const spriteKey = `gravityObject${gravityObjects.length}`;
            graphics.generateTexture(spriteKey, 2, 2);

            this.sprite = scene.add.image(this.position.x, this.position.y, spriteKey);
        }

        drawObject() {
            this.sprite.x = this.position.x;
            this.sprite.y = this.position.y;
        }

        getGravityAccelVector(objectPos) {
            let accelVector = new Phaser.Math.Vector2();
            for (let planet of planets.getChildren()) {
                let toPlanet = planet.body.center.clone();
                toPlanet.subtract(objectPos);
                toPlanet.scale(planet.mass / toPlanet.length()**2);
                accelVector.add(toPlanet);
            }
            return accelVector;
        }

        updatePosition(timeDiff) {
            // Update position via Verlet integration
            let accelVector = this.getGravityAccelVector(this.position);
            let newPos = this.position.clone();
            newPos.add(this.velocity.clone().scale(timeDiff));
            newPos.add(accelVector.clone().scale(timeDiff**2 / 2.0));

            // Update position, save accel so we can update velocity later
            this.position = newPos;
            this.accel = accelVector;
        }

        updateVelocity(timeDiff) {
            let newAccelVector = this.getGravityAccelVector(this.position);
            let newVel = this.velocity.clone();
            newVel.add(this.accel.clone().scale(timeDiff / 2.0));
            newVel.add(newAccelVector.clone().scale(timeDiff / 2.0));

            this.velocity = newVel;
        }

        destroy() {
            this.sprite.destroy();
        }
    }


    function create() {
        graphics = this.add.graphics();

        planets = this.physics.add.group();

        planets.add(new Planet(this, 1e-5, 0xffff00, 50));
        planets.add(new Planet(this, 300, 0xff00ff, 5));
        planets.add(new Planet(this, 200, 0xff00ff, 5));
        playerPlanet = new Planet(this, 400, 0xaaffaa, 5);
        planets.add(playerPlanet);
        planets.add(new Planet(this, 500, 0xff00ff, 15));

        gravityObjects.push(new GravityObject(
            this,
            new Phaser.Math.Vector2(this.cameras.main.centerX, 200),
            new Phaser.Math.Vector2(50, 0),
            0xffaaaa
        ));
        gravityObjects.push(new GravityObject(
            this,
            new Phaser.Math.Vector2(this.cameras.main.centerX + 502, this.cameras.main.centerY),
            new Phaser.Math.Vector2(0, 2),
            0xaaaaff
        ));

        function fireNewProjectile(pointer) {
            if (!pointer.leftButtonDown()) {
                return;
            }
            const mousePos = new Phaser.Math.Vector2(pointer.x, pointer.y);
            let shotDirection = mousePos.clone().subtract(playerPlanet.body.center).normalize();

            gravityObjects.push(new GravityObject(
                this,
                playerPlanet.body.center.clone().add(shotDirection.clone().scale(playerPlanet.radius)),
                shotDirection.scale(50),
                0xaaffaa
            ));
        }

        this.input.on('pointerdown', fireNewProjectile, this);
        this.input.mouse.disableContextMenu();

        console.log(planets);
        console.log(gravityObjects);
    }

    function update() {
        function updatePositions() {
            const timeDiff = 1/60;
            for (let gravityObj of gravityObjects) {
                gravityObj.updatePosition(timeDiff);
            }
            for (let planet of planets.getChildren()) {
                planet.updatePosition();
            }
            for (let gravityObj of gravityObjects) {
                gravityObj.updateVelocity(timeDiff);
            }
        }

        function drawTrajectoryLine(gravityObj, iterations, lineColor=0xff0000) {
            lines = [];
            let objCopy = new GravityObject(
                this,
                gravityObj.position.clone(),
                gravityObj.velocity.clone(),
                0x0
            );

            const updateInterval = 0.5;
            for (let i = 0; i < iterations; i++) {
                const currentPos = objCopy.position.clone();
                objCopy.updatePosition(updateInterval);
                objCopy.updateVelocity(updateInterval);
                lines.push(new Phaser.Geom.Line(
                    currentPos.x, currentPos.y,
                    objCopy.position.x, objCopy.position.y
                ));
            }
            objCopy.destroy();

            graphics.lineStyle(1, lineColor, 0.8);
            for (let line of lines) {
                graphics.strokeLineShape(line);
            }
        }
        drawTrajectoryLine = drawTrajectoryLine.bind(this);

        updatePositions();

        graphics.clear();

        for (let planet of planets.getChildren()) {
            planet.drawObject();
        }

        for (let obj of gravityObjects) {
            obj.drawObject();
        }
        //drawTrajectoryLine(gravityObjects[0], 1000);

        function drawPlayerShotTrajectory() {
            const mousePos = new Phaser.Math.Vector2(game.input.mousePointer.x, game.input.mousePointer.y);
            let shotDirection = mousePos.clone().subtract(playerPlanet.body.center).normalize();
            let trajectoryTracer = new GravityObject(
                    this,
                    playerPlanet.body.center.clone().add(shotDirection.clone().scale(playerPlanet.radius)),
                    shotDirection.clone().scale(50),
                    0x0
            );
            drawTrajectoryLine(
                trajectoryTracer,
                100,
                0x0000ff
            );
            trajectoryTracer.destroy();
        }
        drawPlayerShotTrajectory = drawPlayerShotTrajectory.bind(this);

        drawPlayerShotTrajectory();
    }

</script>

</body>
</html>
