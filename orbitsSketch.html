<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Orbits</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#282c34',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: true
            }
        },
        scene: {
            create: create,
            update: update
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
    }

    let planets;
    let gravityObjects;
    let playerPlanet;

    let graphics;

    class Planet extends Phaser.GameObjects.Image {
        constructor(scene, distance, color, radius) {
            // Create planet "image" from graphics
            graphics.clear();
            graphics.fillStyle(color, 1);
            // TODO: Why does shifting this position affect the image??? Generate image from (0,0), maybe?
            graphics.fillCircle(radius, radius, radius);

            const spriteKey = `planet${planets.getLength()}`;
            graphics.generateTexture(spriteKey, 2*radius, 2*radius);

            let initialPosition = new Phaser.Math.Vector2();
            super(scene, initialPosition.x, initialPosition.y, spriteKey);
            scene.add.existing(this);

            this.t = 0;
            this.radius = radius;

            this.orbitDistance = distance;
            this.mass = radius**2;

            this.orbitPath = new Phaser.Curves.Path();
            this.orbitPath.add(new Phaser.Curves.Ellipse(
                scene.cameras.main.centerX,
                scene.cameras.main.centerY,
                distance
            ));

            scene.tweens.add({
                targets: this,
                t: 1,   // Increase until t hits 1, then loop
                duration: Math.ceil(this.calcOrbitDuration(distance)),
                repeat: -1
            });

            scene.physics.add.existing(this);
            this.body.setCircle(radius);
            this.body.setImmovable(true);   // Will only move by explicit update
        }

        calcOrbitDuration(distance) {
            // Assume 400 units away = 300s orbit
            //  Use Kepler's 3rd law to calculate expected duration
            const baseCircleArea = Math.PI * 400.0**2;
            const baseCircleTime = 300000;   // 300000ms, or 300s
            const currentOrbitArea = Math.PI * distance**2;

            return baseCircleTime * currentOrbitArea / baseCircleArea;
        }

        updatePosition() {
            let newPosition = new Phaser.Math.Vector2();
            this.orbitPath.getPoint(this.t, newPosition);
            this.body.reset(newPosition.x, newPosition.y);
        }

        drawObject() {}
    }

    // NOTE: Gravity objects are affected by gravity, but do NOT affect one another
    class GravityObject extends Phaser.GameObjects.Image {
        constructor(scene, position, velocity, color, damage=10) {
            const radius = 1;
            // Draw image via graphics
            let tempGraphics = scene.add.graphics();
            tempGraphics.fillStyle(color, radius);
            // TODO: Why does shifting this position affect the image??? Generate image from (0,0), maybe?
            tempGraphics.fillCircle(radius, radius, radius);

            const spriteKey = `gravityObject${gravityObjects.getLength()}`;
            tempGraphics.generateTexture(spriteKey, 2*radius, 2*radius);
            tempGraphics.destroy();

            super(scene, position.x, position.y, spriteKey);
            scene.add.existing(this);

            scene.physics.add.existing(this);
            this.body.setCircle(radius);
            this.body.setImmovable(true);   // Will only move by explicit update

            // Body velocity only used to actually move object each frame
            this.position = position.clone();
            this.velocity = velocity.clone();
            this.color = color;
            this.prevPositionsQueue = [];
            this.accel = new Phaser.Math.Vector2();
            this.damage = damage;
        }

        drawObject() {
            // Cap length of trail
            if (this.prevPositionsQueue.length > 10) {
                this.prevPositionsQueue.shift();
            }

            // Draw trail behind it
            for (let i = this.prevPositionsQueue.length - 1; i > 0; i--) {
                const currentPos = this.prevPositionsQueue[i];
                const nextPos = this.prevPositionsQueue[i-1];
                graphics.lineStyle(
                    1,
                    this.color,
                    0.8 * i/this.prevPositionsQueue.length);
                graphics.strokeLineShape(new Phaser.Geom.Line(
                    currentPos.x, currentPos.y,
                    nextPos.x, nextPos.y
                ));
            }
        }

        getGravityAccelVector(objectPos) {
            let accelVector = new Phaser.Math.Vector2();
            for (let planet of planets.getChildren()) {
                let toPlanet = planet.body.center.clone();
                toPlanet.subtract(objectPos);
                toPlanet.scale(planet.mass / toPlanet.length()**2);
                accelVector.add(toPlanet);
            }
            return accelVector;
        }

        updatePosition(timeDiff) {
            // Update position via Verlet integration
            let accelVector = this.getGravityAccelVector(this.position);
            let newPos = this.position.clone();
            newPos.add(this.velocity.clone().scale(timeDiff));
            newPos.add(accelVector.clone().scale(timeDiff**2 / 2.0));

            // Update position, save accel so we can update velocity later
            this.prevPositionsQueue.push(this.body.center.clone());
            this.position = newPos;
            this.accel = accelVector;

            this.body.reset(this.position.x, this.position.y);
        }

        updateVelocity(timeDiff) {
            let newAccelVector = this.getGravityAccelVector(this.position);
            let newVel = this.velocity.clone();
            newVel.add(this.accel.clone().scale(timeDiff / 2.0));
            newVel.add(newAccelVector.clone().scale(timeDiff / 2.0));

            this.velocity = newVel;
        }
    }


    function create() {
        graphics = this.add.graphics();

        planets = this.physics.add.group();
        gravityObjects = this.physics.add.group();

        planets.add(new Planet(this, 1e-5, 0xffff00, 50));
        planets.add(new Planet(this, 300, 0xff00ff, 5));
        planets.add(new Planet(this, 200, 0xff00ff, 5));
        playerPlanet = new Planet(this, 400, 0xaaffaa, 5);
        planets.add(playerPlanet);
        planets.add(new Planet(this, 500, 0xff00ff, 15));

        gravityObjects.add(new GravityObject(
            this,
            new Phaser.Math.Vector2(this.cameras.main.centerX, 200),
            new Phaser.Math.Vector2(50, 0),
            0xffaaaa
        ));
        gravityObjects.add(new GravityObject(
            this,
            new Phaser.Math.Vector2(this.cameras.main.centerX + 502, this.cameras.main.centerY),
            new Phaser.Math.Vector2(0, 2),
            0xaaaaff
        ));

        this.physics.add.collider(planets, gravityObjects,
            (planet, gravityObject) => {
                planet.mass -= gravityObject.damage;
                if (planet.mass <= 0) {
                    planet.destroy();
                }
                gravityObject.destroy();
            }
        );

        function fireNewProjectile(pointer) {
            if (!pointer.leftButtonDown()) {
                return;
            }
            if (!playerPlanet) {
                return;
            }

            const mousePos = new Phaser.Math.Vector2(pointer.x, pointer.y);
            let shotDirection = mousePos.clone().subtract(playerPlanet.body.center).normalize();

            gravityObjects.add(new GravityObject(
                this,
                playerPlanet.body.center.clone().add(shotDirection.clone().scale(playerPlanet.radius+2)),
                shotDirection.scale(50),
                0xaaffaa
            ));
        }

        this.input.on('pointerdown', fireNewProjectile, this);
        this.input.mouse.disableContextMenu();

        console.log(planets);
        console.log(gravityObjects);
    }

    function update() {
        function updatePositions() {
            const timeDiff = 1/60;
            for (let gravityObj of gravityObjects.getChildren()) {
                gravityObj.updatePosition(timeDiff);
            }
            for (let planet of planets.getChildren()) {
                planet.updatePosition();
            }
            for (let gravityObj of gravityObjects.getChildren()) {
                gravityObj.updateVelocity(timeDiff);
            }
        }

        function drawTrajectoryLine(gravityObj, iterations, lineColor=0xff0000) {
            lines = [];
            // NOTE: GravityObjects ONLY used to draw trajectory; should not collide w/ anything
            if (!gravityObj) {
                return;
            }
            let objCopy = new GravityObject(
                this,
                gravityObj.position,
                gravityObj.velocity,
                0x0
            );

            const updateInterval = 0.5;
            for (let i = 0; i < iterations && objCopy; i++) {
                const currentPos = objCopy.position.clone();
                objCopy.updatePosition(updateInterval);
                objCopy.updateVelocity(updateInterval);
                lines.push(new Phaser.Geom.Line(
                    currentPos.x, currentPos.y,
                    objCopy.position.x, objCopy.position.y
                ));
            }
            objCopy.destroy();

            let counter = 0;
            for (let line of lines) {
                graphics.lineStyle(1, lineColor, 0.8 * (iterations-counter)/iterations);
                graphics.strokeLineShape(line);
                counter+=1;
            }
        }
        drawTrajectoryLine = drawTrajectoryLine.bind(this);

        updatePositions();

        graphics.clear();

        for (let planet of planets.getChildren()) {
            planet.drawObject();
        }

        for (let obj of gravityObjects.getChildren()) {
            obj.drawObject();
        }

        function drawPlayerShotTrajectory() {
            if (!playerPlanet) {
                return;
            }

            const mousePos = new Phaser.Math.Vector2(game.input.mousePointer.x, game.input.mousePointer.y);
            let shotDirection = mousePos.clone().subtract(playerPlanet.body.center).normalize();
            let trajectoryTracer = new GravityObject(
                    this,
                    playerPlanet.body.center.clone().add(shotDirection.clone().scale(playerPlanet.radius)),
                    shotDirection.scale(50),
                    0x0
            );
            drawTrajectoryLine(
                trajectoryTracer,
                100,
                0xaaaaff
            );
            trajectoryTracer.destroy();
        }
        drawPlayerShotTrajectory = drawPlayerShotTrajectory.bind(this);

        drawPlayerShotTrajectory();
        drawTrajectoryLine(gravityObjects.getChildren()[0], 1000);
    }

</script>

</body>
</html>
